## 풀이

#### 접근 방법

문제의 핵심은 A와 가장 차이가 적은 B의 값을 매칭시키는 것이다. 따라서, **이분 탐색** 의 `upper bound` 알고리즘을 이용하면 된다.



#### 구현 방법

- 먼저, A와 B를 오름차순으로 정렬한다. 

- B에서 이미 선택된 요소를 선택하지 않기 위해 visited를 만든다.

- A 리스트를 for문으로 순회하면서 매칭되는 B의 값을 upper bound로 찾는다.

  - Upper bound

    left가 right보다 크거나 같을때까지 계속 재귀 호출한다.

    만약, **현재 a 값보다 작다면, 방문한 경우랑 방문하지 않은 경우를 나눠야한다.** <u>방문하지 않았다면</u>, 현재의 mid값까지 후보가 될 수 있으므로 `right를 mid`로 설정한 후에 재귀 호출한다. <u>방문했다면</u>, 그 지점까지는 이미 답이 될 수 없다. (동일 값의 경우, 무조건 앞에서부터 선택되기 때문에 현재 mid는 방문했고, 앞에서 동일값이면서 방문하지 않은 곳은 있을 수 없다.)

    따라서, `left를 mid + 1`로 설정하고 다시 재귀 호출한다. **현재 a이 더 크거나 같은 경우** 승점을 얻을 수 없으므로 이 경우도 `left를 mid + 1`로 설정하고 재귀 호출한다.



