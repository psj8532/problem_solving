## 풀이

#### 시간복잡도

최악의 경우 **20!**이기 때문에 완전 탐색으로 접근하면 안된다.



#### 아이디어

숫자는 1~n까지 있고 오름차순으로 순번을 정하기 때문에 각 자릿수를 연산으로 한번에 정할 수 있겠다는 생각이 들었고, 규칙을 찾을 수 있었다. 현재 자리를 제외한 **나머지 길이의!**을 이용하는 것이다.

예를 들어, [1,2,3]가 있다고 해보자. 첫째 자리를 정해야하는데, 첫째자리를 제외한 나머지 길이는 2이다. 이제 2!로 자릿수를 찾아낼 것이다. 2! * idx를 했을 때 k(5)랑 비교해서 k값보다 크거나 같은 값이 나올 때까지 idx를 1씩 증가시면서 만족하는 idx를 찾는다. 이때, idx는 3이고 lst의 [2]에 있으므로 idx -1 을 해주고 lst에서 값을 빼내고 answer에 추가해준다. 앞자리가 한자리 작은숫자까지는 고려할 필요없으므로 ns(길이!)*idx만큼 k에서 빼준다. 이 과정을 반복하면 모든 자릿수가 맞춰진다.

이 풀이법의 경우 20번 한번 돌고 중첩 반복문은 이보다 더 적게 돌기 때문에 효율성 케이스도 문제없이 통과할 수 있다.



## 코드

 ```python
def solution(n, k):
    answer = []
    lst = [i for i in range(1, n+1)]
    nums = n-1
    while nums >= 0:
        if not nums: ns = 0
        else:
            ns = 1
            for i in range(nums,0,-1):
                ns *= i
        idx = 1
        while ns and ns * idx < k:
            idx += 1
        idx -= 1
        num = lst.pop(idx)
        answer.append(num)
        nums -= 1
        k -= ns * idx
    return answer
 ```

