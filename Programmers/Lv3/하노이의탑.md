## 풀이

#### 알고리즘

**분할-정복** 알고리즘의 대표적인 문제이다.



#### 아이디어

**현재 수** 만 기준으로 생각한다. 예를 들어, `1,2,3`이 있다고 가정해보자. 현재 나는 제일 큰 수 3을 **목표했던 기둥으로 옮기는 데 집중**할 것이다. 그러기 위해서는 위에 있는 `1,2` 를 비어있는 나머지 하나의 기둥으로 옮겨야한다. 이 나머지 하나의 기둥을 **서브 기둥**이라고 이름 붙였다. 다시 서브 기둥으로 옮겨야하는 숫자 중에서 가장 큰 수를 위와 같은 과정을 통해 반복한다. 재귀의 최대 깊이인 원판이 1인 곳이 나타나면 그 때의 목표로 옮기고 돌아온다. 이후, 원래 숫자를 목표 기둥으로 옮기고, 서브에 있던 원판을 다시 가져와야하므로 한번 더 재귀를 호출한다.

정리하면, **현재 수를 기준**으로 잡고, **현재 수 위에 있는 수들을 서브 기둥으로** 옮긴다. 그 다음, **현재 수를 목표 기둥으로** 옮긴다. 마지막으로 **서브 기둥에 있던 수를 목표 기둥으로** 옮긴다.







## 코드

```python
def solution(n):
    def hanoi(cur, target, sub, num):
        if num == 1:
            answer.append([cur, target])
            print('num: ', num)
            print(cur,target)
            return
        hanoi(cur, sub, target, num-1)
        answer.append([cur, target])
        hanoi(sub, target, cur, num-1)

    answer = []
    hanoi(1, 3, 2, n)
    return answer
```

