## 문제풀이

규칙을 찾지 못해서 그리디 알고리즘으로 풀었으나 시간초과가 발생했다. 거스름돈으로 사용하는 동전의 갯수를 최소한으로 할 땐, 그리디 알고리즘이 효율적이나 모든 경우의 수를 탐색하기 위해서는 **DP**를 이용해야한다.



#### 구현 방법

- 경우의 수를 저장할 `dp` 리스트를 준비한다.

  행은 `화폐 단위`, 열은 `수`, 값은 `경우의 수`를 나타낸다. 

- 첫번째 화폐로 만들 수 있는 수에 1을 표시한다. (화폐는 오름차순 되있어야 한다.)

  0의 경우 나중에 더해줄 때, 분기를 없애기 위해 1로 만든다.

- 두번째 화폐부터는 규칙이 적용된다.

  행이 바뀔 때마다 새로운 화폐 단위가 추가되는 것인데, 3가지 경우로 나눌 수 있다.

  1. 화폐 단위가 수보다 작을 경우

     화폐 단위가 2인 경우를 살펴보자. 2가 새로 추가됐지만 1까지는 화폐 2를 사용할 수 없다. 5의 경우 4까지는 5를 쓸 수 없다. 따라서, 이전 행의 경우의 수와 같다.

  2. 2번과 3번의 경우, 이전 행의 경우의 수에 새로운 경우의 수가 추가된다. 먼저 화폐 단위와 수가 같을 경우

     `새로 추가된 화폐 단위`로 그 수를 만들 수 있기 때문에 +1이 된다.

     

  3. 수가 화페 단위보다 클 경우

     `수 - 화폐 단위`에 있는 경우의 수와 `이전 행`의 경우의 수를 더해주면 된다. 수 - 화폐 단위를 하는 이유는 수는 화폐단위 + x로 이루어질 것이다. 이전 행에는 새로운 화폐가 추가되기 전 경우의 수가 저장 되있다. 여기에 새로운 화폐가 추가되면서 x를 만드는 경우에서 새로 들어온 화폐만 추가해주는 것이므로 경우의 수는 그대로 동일하다. 따라서, 이전 행에서 새로운 화폐가 추가되기 전 경우의 수와 더해주면 새로운 화폐가 들어왔을 때를 구할 수 있다. 예를 들어보면, 화페 단위가 2이고 만들어야 할 수가 4다. 이전 행에서 만들 수 있는 경우의 수는 1이다. 여기에 화폐 2가 추가되면서 2 (4-2)를 만들 수 있는 경우의 수 2를 더해줘야한다.

  |  화폐 단위 / 수   |  0   |  1   |  2   |  3   |  4   |  5   |
  | :---------------: | :--: | :--: | :--: | :--: | :--: | :--: |
  |  1(행 번호) <= 1  |  1   |  1   |  1   |  1   |  1   |  1   |
  |  2 <= 1,2로 만듬  |  1   |  1   |  2   |  2   |  3   |  3   |
  | 5 <= 1,2,5로 만듬 |  1   |  1   |  2   |  2   |  2   |  4   |



=> 다른 사람의 풀이를 보는데도 이해하기 매우 힘들었던 문제이다. 



## 코드

#### DP

```python
def solution(n, money):
    dp = [1] + [0] * n
    for coin in money:
        for j in range(coin, n+1):
            dp[j] += dp[j-coin]
    return dp[n] % 1000000007
```

```java
class Solution {
    public int solution(int n, int[] money) {
        int[] dp = new int[n+1];
        dp[0] = 1;
        for (int i = money[0]; i<=n; i+=money[0]) {
            dp[i] = 1;
        }
        for (int i = 1; i < money.length; i++) {
            for (int j = money[i]; j <= n; j++) {
                dp[j] = (dp[j] + dp[j-money[i]]) % 1000000007;
            }
        }
        return dp[n];
    }
}
```

#### 그리디

```python
# 효율성 통과 못함
def solution(n, money):
    def recursion(total, idx):
        nonlocal answer
        if total == n:
            answer = (answer + 1) % 1000000007
            return
        if idx < 0: return
        for i in range(idx,-1,-1):
            unit = money[i]
            q = (n-total) // unit
            for j in range(q+1,0,-1):
                temp = unit * j
                if total + temp > n: continue
                recursion(total+temp, i-1)


    answer, N = 0, len(money)
    recursion(0, N-1)
    return answer
```



#### 참고

https://ydeer.tistory.com/59
