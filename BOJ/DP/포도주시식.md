# 포도주 시식

### 알고리즘

- DP

### 생각

- 계단 오르기와 비슷한 유형
- 계단 오르기 보다 좀 더 DP답게 풀기 위해 고민
  - 2차원 dp리스트 사용

### 틀린 이유

- 전과 전전 잔을 마시지 않으면 최댓값이 될 수 없다고 생각하고 풀어서 오류 발생
  - 가운데 2잔을 비웠을때 최대가 될 수 있음 O O X X O O
  - 가운데 3잔이 비면 최댓값이 될 수 없는 이유는 젤 가운데 하나를 선택하는 것이 셋다 비우는 것보단 값이 크거나 같기 때문이다.

### 해결 방법

- 열을 하나 더 추가하여 전과 전전 잔을 모두 마시지 않았을때, i-3번째에서 최댓값을 가져와 더해줌

- [] [2]열이 추가됨에 따라 이전것에서 [] [0], [] [2]의 최댓값을 비교해서 가져와야함



### 구현 방법

- 2차원 리스트 dp 필요
- 점화식을 세워서 3번째 잔 부터는 경우의 수를 나눔
  - 전전 x + 전 o => [현재] [1]
  - 전전 o + 전 x =>max([현재-2]) => [현재] [0]
  - 전전 x + 전 x => max([현재-3]) => [현재] [2]



### 참고

- DP 풀이 방법
  - dp 배열을 이용하여 전체를 한번만 살펴보게 해야함
  - 점화식 이용



### 코드

- python

  ```python
  N = int(input())
  arr = []
  for _ in range(N):
      arr.append(int(input()))
  dp = [[0]*3 for _ in range(N)]
  dp[0][0] = arr[0]
  if N > 1:
      dp[1][0] = arr[1]
      dp[1][1] = dp[0][0] + arr[1]
      for i in range(2,N):
          dp[i][0] = max(dp[i-2]) + arr[i]
          dp[i][1] = max(dp[i-1][0],dp[i-1][2]) + arr[i]
          if i > 2: dp[i][2] = max(dp[i-3]) + arr[i]
      answer1 = max(dp[N-2])
      answer2 = max(dp[N-1])
      print(answer1 if answer1 >= answer2 else answer2)
  else:
      print(dp[0][0])
  ```

  