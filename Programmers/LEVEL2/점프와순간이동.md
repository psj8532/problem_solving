### 풀이

##### 처음 생각했던 아이디어

최대한 순간이동을 해야한다. 현재 위치를 기준으로 1칸 이동한 후에 순간이동하면, 도착지점에 도착한 경우와 넘어간 경우로 나눈다. 넘어갔다면 실패한 것이므로 현재 위치에서 1칸 이동 후에 위 과정을 반복한다.

=> 효율성에 문제가 없을것이라고 생각했다. 하지만 효율성 테스트 케이스 3개가 시간초과가 났다.



##### 참고한 아이디어

나는 처음부터 출발해야한다고 생각했는데, 도착지점에서부터 거꾸로 가는 방법이 존재했다. 그 이유를 살펴보니, 1부터 2의 배수로 커지기 떄문에 2의 제곱수로 순간이동한다. 도착지점에서 2로 나누면 최대한 순간이동으로 갈 수 있는 곳까지 갈 수 있다. 만약 홀수라면, 한 번은 움직여야한다. 그래서 1을 빼주고 다시 위 과정을 반복한다. 



##### 시간복잡도

풀이1의 경우, 계속 2배씩 이동하면서 확인한다. 이 숫자가 매우 크다고 가정할때, 목표지점보다 멀리간다면 기껏 계산한 과정을 버리고, 1칸 이동후에 다시 계산하게 된다. 하지만 풀이2의 경우, 짝수,홀수인지만 판별하고 아니라면 1빼고 계속 이동하므로 계산 결과를 버리는 일이 없다. 이 점이 결정적인 차이점이다.



### 코드

- 풀이1

```python
def solution(n):
    ans = 0
    here = 0
    while True:
        move = 1
        ans += move
        while here + move * 2 <= n:
            move *= 2
        print('현재위치: ', here)
        here += move
        print('이동위치: ', here, '이동해야할 위치: ', move, '건전지: ', ans)
        if here == n:
            break

    return ans
```

- 풀이2

```python
def solution(n):
    ans = 1
    here = n
    while here != 1:
        while not here % 2:
            here //= 2
        if here != 1:
            ans += 1
            here -= 1

    return ans
```

